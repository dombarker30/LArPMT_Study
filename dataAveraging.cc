/***

Reads a .root file generated by waveform.cc
Creates an output .root file containing 1 folder per channel

Each folder contains : -Graphs of the averaged waveform (linear & log)
							  -An array filled with the coresponding data
							  -A histogram of the peak amplitudes
							  
							  -An "exponential" fit
							  -A linear fit in log-scale
							  

Uses : ./dataAveraging inputFileName outputFileName [opts]
		 ./dataAveraging folderName


Compile with : g++ dataAveraging.cc -o dataAveraging `root-config --cflags --libs`

***/

#include <iostream>
#include <string.h>
#include <cmath>

#include "TROOT.h"
#include "TApplication.h"
#include "TFile.h"
#include "TTree.h"
#include "TBrowser.h"
#include "TH1.h"
#include "TF1.h"
#include "TGraph.h"
#include "TArray.h"
#include "TDirectory.h"

#include "TCanvas.h"
#include "TString.h"
#include "TStyle.h"

#include "TSystem.h"
#include "TFitResult.h"



#define N_WF 20000

//Defining log fit range
#define LOGFIT_XMIN 10300
#define LOGFIT_XMAX 11100

//Normalisation constant for fitting
#define NORM 100


using namespace std;

void readDirectory(char const* dirName);
void readTree(char const* inputFileName, char const* outputFileName, char const* opts = "");

TH1F* plot(TCanvas*c, TH1F* h);
TH1F* arrayToHist(char const* name, char const* title, float_t* array, int n, double xmin = 0, double xmax = 0);
void upPeak(float_t* wf, int n, char const* opts = "");

bool ringing(vector<float>* waveform, Float_t amp);


//Fit-----------------------------------------------------------

struct FitResults {
	vector<float> params;
	vector<float> errLow;
	vector<float> errUp;
	float chi2;
	float rchi2;
};

FitResults avFit(TH1F* h, int nExp, int option);
TF1* fitFunction(int peakTime, int nExp, int option);

//---------------------------------------------------------------

TApplication* app = NULL;

int main (int argc, char *argv[])
{
	if(argc < 2) {
		cout << "Please specify input and output .root filenames" << endl;
		return 1;
	}
	else if(argc == 2)
	{//Averaging all files in directory
		readDirectory(argv[1]);
		return 0;
	}
	
	TH1::AddDirectory(kFALSE);
		
	char* inputFileName = argv[1];
	char* outputFileName = argv[2];
	
	char const* opts = (argc == 4) ? argv[3] : "";
	
	if(!strcmp(opts, "draw") || !strcmp(opts, "rms"))
		app = new TApplication("app", &argc, argv);
	
	readTree(inputFileName, outputFileName, opts);
	
	return 0;
}

void readDirectory(char const* dirName)
{
	/* For each *.root file in the directory, computes the averaged waveform 
		and writes it in AveragedWF/av_*.root	*/
		
	string dir(dirName);
	void *dirp = gSystem->OpenDirectory(dir.c_str());
	
	Char_t *s;
	while ((s = const_cast<Char_t *>(gSystem->GetDirEntry(dirp))))
	{
		if(!string(s).compare(".") || !string(s).compare(".."))
			continue;
			
		string inputFileName = s;
		size_t p = inputFileName.find(".root");
		
		//If fileName does not contain "2018070" , or if fileName contains "111622_whilst", then ignore the file
		if(p==string::npos || inputFileName.find("2018070") == string::npos
			|| inputFileName.find("111622_whilst") != string::npos )
			continue;
		
		string outputFileName = inputFileName;
		outputFileName = "av_" + outputFileName;
		
		if(!gSystem->OpenDirectory((dir + "/AveragedWF").c_str()))
			gSystem->Exec(("mkdir " + dir + "/AveragedWF").c_str());

		readTree((dir + "/" + inputFileName).c_str(), (dir + "/AveragedWF/" + outputFileName).c_str());
	}
}

void readTree(char const* inputFileName, char const* outputFileName, char const* opts)
{
	//draw & rms options
	TCanvas* c = NULL;
	TH1F* hRMS = NULL;

	if(!strcmp(opts, "draw") || !strcmp(opts, "rms")) {
		c = new TCanvas("c", "Waveform averaging", 800, 800);
		TH1::AddDirectory(kFALSE);
	}
	if(!strcmp(opts, "rms"))
	{
		hRMS = new TH1F("rms", "rms", 100, 0, 1);
		hRMS->GetXaxis()->SetTitle("RMS (ADC)");
	}

	//------------------------ Reading input file -------------------------
	
	TFile *f = new TFile(inputFileName, "READ");
	if (!f) { cout << "Unable to open the root file." << endl; return; }
		cout << "\n------- Reading file \"" << inputFileName << "\" -------\n" << endl;

	TTree *t1 = (TTree*)f->Get("pulsetree");

	Int_t channel, source;
	Float_t baseVolt, baseRmsVolt, amplitudeVolt, maxVolt, peaktimeSec,
			  baseAdc,  baseRmsAdc,  amplitudeAdc,  maxAdc,  peaktimeTdc;
	vector<float>* waveform = NULL;
	
	t1->SetBranchAddress("channel",&channel);
	t1->SetBranchAddress("source",&source);
	t1->SetBranchAddress("baseVolt",&baseVolt);
	t1->SetBranchAddress("baseAdc",&baseAdc);
	t1->SetBranchAddress("baseRmsVolt",&baseRmsVolt);
	t1->SetBranchAddress("baseRmsAdc",&baseRmsAdc);
	t1->SetBranchAddress("amplitudeVolt",&amplitudeVolt);
	t1->SetBranchAddress("amplitudeAdc",&amplitudeAdc);
	t1->SetBranchAddress("maxVolt",&maxVolt);
	t1->SetBranchAddress("maxAdc",&maxAdc);
	t1->SetBranchAddress("peaktimeSec",&peaktimeSec);
	t1->SetBranchAddress("peaktimeTdc",&peaktimeTdc);
	t1->SetBranchAddress("waveform",&waveform);
	
	//Defining vectors (one element per channel) ---
	
	vector<Int_t> channels; //Channels
	bool channelIsNew;
	int channelIndex = -1;

	vector<array<float, N_WF>> waveformsAv; //Average waveform arrays vector
		float cutLow = 0;
		float cutUp = 1000;
		
	array<float, N_WF> emptyArray = {0};
	int k = 0;

	vector<TH1F*> histograms; //Histograms vector

	vector<Long64_t> nWF; //Number of entries vector
	
	//Reading tree ---
	
	Long64_t nentries = t1->GetEntries();
	
	for (Long64_t i=0;i<nentries;i++) {
		t1->GetEntry(i);
		
		channelIsNew = ( find(channels.begin(), channels.end(), channel) == channels.end() );
		
		if(channelIsNew) {
		//If channel number has not been encountered yet, extends the vectors and initialises the new elements
			channels.push_back(channel);
			
			waveformsAv.push_back(emptyArray);
			
			histograms.push_back(new TH1F(("Ch" + to_string(channel) + "Amplitude").c_str(), "Pulse Amplitude", 100, 0, 0.5));
			histograms.back()->SetDirectory(0);
			histograms.back()->SetCanExtend(TH1::kXaxis);
			histograms.back()->GetXaxis()->SetTitle("ADC");
			
			nWF.push_back(0);
			
			channelIndex = channels.size()-1;
		}
		else {
		//If channel has already been encountered, determines the corresponding index to access elements
			for(k=0; k<channels.size(); k++) { 
				if(channels.at(k) == channel) {
					channelIndex = k;
					break;
				}
			}
		}
		
		
		//RMS computation + max baseline value
		int nMax = 8000;
		float mean = 0;
		int maxBaseline = 0;
			
		for(k=0; k<nMax; k++) {
			mean += waveform->at(k);
			maxBaseline = (waveform->at(k) > maxBaseline) ? waveform->at(k) : maxBaseline;
		}
		mean /= nMax;
			
		float rms = 0;
			
		for(k=0; k<nMax; k++)
			rms += pow((waveform->at(k) - mean), 2);
			
		rms = sqrt(rms/nMax);
		
		if(!strcmp(opts, "draw"))
		{
			c->Clear();
			c->cd();
			
			TH1F* drawHist = arrayToHist( ("AvWF " + to_string(i+1) + "/" + to_string(nentries)).c_str(),
													("Averaged WF " + to_string(i+1) + "/" + to_string(nentries)).c_str(),
													 waveform->data(), N_WF) ;
			
			drawHist->GetXaxis()->SetRange(9250, 10750);
			drawHist->GetYaxis()->SetRangeUser(-30, 110);
			
			plot(c, drawHist);
			gPad->WaitPrimitive();
			
			delete drawHist;
		}
		else if(!strcmp(opts, "rms"))
		{
			cout << "RMS " << "(" << i+1 << "/" << nentries << ") : " << rms << endl;
			hRMS->Fill(rms);
				
			if(rms > 1)
			{//Plot waveform is RMS is high
				c->Clear();
				c->cd();
				TH1F* drawHist = arrayToHist( ("AvWF " + to_string(i+1) + "/" + to_string(nentries)).c_str(),
											  			("Averaged WF " + to_string(i+1) + "/" + to_string(nentries)).c_str(),
											 			 waveform->data(), N_WF);
				plot(c, drawHist);
				gPad->WaitPrimitive();
			}

		}
		
		//Selection criteria for individual waveforms
		if(rms > 5 || ringing(waveform, amplitudeAdc) || !(amplitudeAdc > cutLow && amplitudeAdc < cutUp) )
			continue;
		
		for(k=0; k<N_WF; k++) {
			waveformsAv.at(channelIndex).at(k) += waveform->at(k);
		}
		
		histograms.at(channelIndex)->Fill(amplitudeAdc);

		nWF.at(channelIndex) ++;	
	}
	
	//From sum to average
	for(channelIndex=0; channelIndex<channels.size(); channelIndex++) {
		for(k=0; k<N_WF; k++)
			waveformsAv.at(channelIndex).at(k) /= nWF.at(channelIndex);
		cout << nWF.at(channelIndex) << " recorded events (up on " << nentries << ")." << endl;
	}
	

	f->Close();

	if(!strcmp(opts, "draw") || !strcmp(opts, "rms"))
	{
		if(!strcmp(opts, "rms"))
		{
			hRMS->Draw();
			c->Update();
		}
		
		app->Run();
		return;
	}
	  
		
		
	//------------------------ Writing output file ------------------------
	
	f = new TFile(outputFileName, "RECREATE");
		cout << "\n------- Writing info in file \"" << outputFileName << "\" -------\n" << endl;
	
	TGraph* g = NULL;
	TArrayF* a = NULL;
	TH1F* hWF = NULL;
	
	if(channels.size() > 1) //If there are more than 1 channel, results written in 1 directory per channel
	{
		TDirectory **chDir = new TDirectory*[channels.size()];
		
		for(channelIndex=0; channelIndex<channels.size(); channelIndex++) {
		cout << "\nCh" << channels.at(channelIndex) << " waveform graph written in file" << endl;
			chDir[channelIndex] = f->mkdir(("Ch" + to_string(channels.at(channelIndex))).c_str());
			chDir[channelIndex]->cd();
			
			hWF = arrayToHist("AvWF", "Averaged waveform", waveformsAv.at(0).data(), N_WF);
			a = new TArrayF(N_WF, waveformsAv.at(channelIndex).data());		
			
			hWF->Write("Graph");
				cout << "\nCh" << channels.at(channelIndex) << " waveform graph written in file" << endl;
			chDir[channelIndex]->WriteObject(a, "Array");
				cout << "Ch" << channels.at(channelIndex) << " waveform array written in file" << endl;
			histograms.at(channelIndex)->Write();
				cout << "Ch" << channels.at(channelIndex) << " amplitudes histogram written in file\n" << endl;
				
			delete hWF;
			delete a;			
		}
	}
	else
	{ //Only one channel
		a = new TArrayF(N_WF, waveformsAv.at(0).data()); 
	  
		//----Waveform graph----
		
		hWF = arrayToHist("AvWF", "Averaged waveform", waveformsAv.at(0).data(), N_WF);
		
		hWF->GetXaxis()->SetTitle("Ticks");
		hWF->GetYaxis()->SetTitle("ADC count");
		hWF->Write();

		delete hWF;


		//----Waveform log graph----
		
		array<float, N_WF> logArr = waveformsAv.at(0);
		upPeak(logArr.data(), N_WF, "log10");
		
		hWF = arrayToHist("AvWF(log)", "Averaged waveform (log)", logArr.data(), N_WF);
		
		hWF->GetXaxis()->SetTitle("Ticks");
		hWF->GetYaxis()->SetTitle("log10(ADC count)");
		
		hWF->Write();
		
		delete hWF;
		
		
		if(strcmp(opts, "nofit"))
		{
			//----Fit----
			
			array<float, N_WF> fitArr = waveformsAv.at(0);
			upPeak(fitArr.data(), N_WF, "norm");
			
			hWF = arrayToHist("AvWF", "Fitting", fitArr.data(), N_WF);
			
			gStyle->SetOptStat(0);
			avFit(hWF, 2, 1);
			hWF->Write("fit");
			
			delete hWF;
			
			
			//----LogFit----
			
			TCanvas* clog = new TCanvas("logFit", "logfit", 800, 800);
			
			array<float, N_WF> logFitArr = waveformsAv.at(0);
			upPeak(logFitArr.data(), N_WF, "log");
			
			hWF = arrayToHist("AvWF", "Log fit", logFitArr.data(), N_WF);
			gStyle->SetOptStat(0);
			
			auto results = avFit(hWF, 0, 4);
			
			hWF->GetFunction("fit")->SetLineStyle(4);
			hWF->GetFunction("fit")->SetRange(9500, 15000);
			
			clog->Clear();
			clog->Divide(1, 2);
			clog->cd(1);
			hWF->Draw();
			
			array<float, N_WF> nolog = waveformsAv.at(0);
			upPeak(nolog.data(), N_WF, "");
			
			TH1F* hNolog = arrayToHist("AvWF-nolog", "Corresponding exponential", nolog.data(), N_WF);
			
			TF1* expFunc = new TF1("expFit", "exp([0] - x/[1])", 10000, N_WF);
				expFunc->SetParameter(0, results.params.at(0));
				expFunc->SetParameter(1, results.params.at(1));
			
			clog->cd(2);
			
			hNolog->GetXaxis()->SetTitle("Ticks");
			hNolog->GetYaxis()->SetTitle("ADC count");
			
			hNolog->Draw();
			expFunc->Draw("SAME");
			
			clog->Write();
			
			delete hWF;
			delete hNolog;
			delete expFunc;
			delete clog;
		}
		
		
		
		histograms.at(0)->Write("Amplitudes");
		f->WriteObject(a, "Array");
		 
		delete a;
	}
	
	f->Close();
}


TH1F* plot(TCanvas*c, TH1F* h)
{
	h->SetStats(kFALSE);
	h->Draw();
	c->Update();
	
	return h;
}

TH1F* arrayToHist(char const* name, char const* title, float_t* array, int n, double xmin, double xmax)
{
	if(!xmax)
		xmax=n;
		
	TH1F* hist = new TH1F(name, title, n, xmin, xmax);
	
	for (Int_t bin = 1; bin <= n; bin++){
		hist->SetBinContent(bin, (float_t) array[bin-1]);
	}
	
	return hist;
}


void upPeak(float_t* wf, int n, char const* opts)
{
	/* Flips the waveform "upside-down". Possible options : "log10", "log" and "norm" (for normalising max waveform value) */
	
	int nMin = 12000;
	int nMax = 20000;
	float_t max = wf[nMin];
	float_t max2 = wf[nMin];
	
	float_t min = wf[0];
	
	for(int i=nMin; i<nMax; i++) {
		if(wf[i] > max) {
			max2 = max;
			max = wf[i];
		}
	}
	for(int i=1 ; i<n ; i++)
	{
		if(wf[i] < min)
			min = wf[i];
	}
	
	for(int i=0; i<n; i++) {
		if (opts == "log10")
			wf[i] = (wf[i] < max) ? log10(max - wf[i]) : log10(max - max2);
		else if (opts == "log")
		{
			wf[i] = (wf[i] < max) ? log(max - wf[i]) : log(max - max2);
		}
		else if(opts == "norm")
		{
			
			wf[i] = NORM*(max - wf[i])/(max-min);
		}
		else 
			wf[i] = max - wf[i];
	}
}

bool ringing(vector<float>* waveform, Float_t amp)
{	
	/*Returns true if ringing goes above baseline */
	
	int nMax = 8000;
	int maxBaseline = 0;
			
	for(int k=0; k<nMax; k++)
		maxBaseline = (waveform->at(k) > maxBaseline) ? waveform->at(k) : maxBaseline;
		
	int maxRinging = 0;
		
	for(int k=10000; k<10200; k++) {
		maxRinging = (waveform->at(k) > maxRinging) ? waveform->at(k) : maxRinging;
	}
	
	if (maxRinging >= maxBaseline)
		return true;
	return false;
}


//-----------------------------------------------------------//
//-----------------------Fitting-----------------------------//
//-----------------------------------------------------------//

FitResults avFit(TH1F* h, int nExp, int option)
{
	FitResults fitResults;
	
	//TCanvas* c = new TCanvas("c", "Exponential fitting", 100, 100, 800, 800);

	int peakTime = h->GetMaximumBin();
	TF1* func = fitFunction(peakTime, nExp, option);
	TFitResultPtr r;
	
	//Fitting
	if(option != 4)
		r = h->Fit("fit", "M Q E S", "", peakTime+5, N_WF);
	else
		r = h->Fit("fit", "M Q E S", "", LOGFIT_XMIN, LOGFIT_XMAX);
	gStyle->SetOptFit(0111);

	for(int i = 0; i<func->GetNpar() ; i++) {
		fitResults.params.push_back(func->GetParameter(i));
		fitResults.errLow.push_back(r->LowerError(i));
		fitResults.errUp.push_back(r->UpperError(i));
	}
	fitResults.chi2 = func->GetChisquare();
	fitResults.rchi2 = func->GetChisquare()/func->GetNDF();

	return fitResults;
}

TF1* fitFunction(int peakTime, int nExp, int option)
{
	TF1* func = NULL;
	
	//Constants definition
	float tauT = 1210; //[ns]				1210 in O2 paper / 1260 in N2 paper
	float tauS = 4.9; //[ns]
	float tauI = 34; //[ns]
	
	float k_O2 = 5.4e-4; //[ppm(-1).ns(-1)]
	float k_N2 = 1.1e-4; //[ppm(-1).ns(-1)]
	
	float beta_O2 = 13; //[ppm]
	float beta_N2 = 530; //[ppm]

	
	bool fixPeakTime = true;
	int peakTimeNb = -1;
	
	switch(option)
	{
		case 1 : //Fitting amplitudes & time constants
			switch(nExp)
			{
				case 3 :
					if(!func)
						func = new TF1("fit", "[0] + [1]*exp(-1/[2]*(x-[3])) \
															+ [4]*exp(-1/[5]*(x-[3])) \
															+ [6]*exp(-1/[7]*(x-[3]))", 0, N_WF);

					func->SetParLimits(6, 0, 1.5 * NORM);//Intermediate state amplitude
						func->SetParName(6, "Amp_I");
						func->SetParameter(6, 1. * NORM);
					func->SetParLimits(7, 0, 1e4);//Intermediate state time constant 
						func->SetParName(7, "Tau_I");
						func->SetParameter(7, 50.);
				case 2 :
					if(!func)
						func = new TF1("fit", "[0] + [1]*exp(-1/[2]*(x-[3])) \
															+ [4]*exp(-1/[5]*(x-[3]))", 0, N_WF);

					func->SetParLimits(4, 0, 1.5 * NORM);//Singulet-state amplitude
						func->SetParName(4, "Amp_S");
						func->SetParameter(4, 1. * NORM);
					func->SetParLimits(5, 0, 1e4);//Singulet-state time constant 
						func->SetParName(5, "Tau_S");
						func->SetParameter(5, 5.);
				case 1 :
					if(!func)
						func = new TF1("fit", "[0] + [1]*exp(-1/[2]*(x-[3]))", 0, N_WF);

					func->SetParLimits(0, 0, 1 * NORM);//Offset
					  func->SetParName(0, "Offset");
						func->SetParameter(0, 0.);
					
					func->SetParLimits(1, 0, 1.5 * NORM);//Triplet-state amplitude
						func->SetParName(1, "Amp_T");
						func->SetParameter(1, 1. * NORM);
					func->SetParLimits(2, 0, 1e4);//Triplet-state time constant
						func->SetParName(2, "Tau_T");
						func->SetParameter(2, 1000.);
					
					func->SetParLimits(3, peakTime-20, peakTime+20);//Peak time
						func->SetParName(3, "PeakTime");
					
					break;
				default :
					cout << "nExp value must be 1, 2 or 3" << endl;
					return NULL;
			}
			
			peakTimeNb = 3;
			
			break;
		case 2 : //Fitting O2 and N2 concentrations 
			switch(nExp)
			{
				case 3 :
					if(!func)
						func = new TF1("fit", "[0] + [1] *exp(-(1/[2]  + [3]*[4] + [5]*[6])*(x-[7])) \
															+ [8] *exp(-(1/[9]  + [3]*[4] + [5]*[6])*(x-[7])) \
															+ [10]*exp(-(1/[11]		+		[5]*[6])*(x-[7]))", 0, N_WF);
					
					func->SetParLimits(10, 0, 1.5 * NORM);//Intermediate state amplitude
						func->SetParName(10, "Amp_I");
						func->SetParameter(10, 1. * NORM);
					func->FixParameter(11, tauI);//Intermediate state time constant 
						func->SetParName(11, "Tau_I");
				
				case 2 :
					if(!func)
						func = new TF1("fit", "[0] + [1] *exp(-(1/[2]  + [3]*[4] + [5]*[6])*(x-[7])) \
															+ [8] *exp(-(1/[9]  + [3]*[4] + [5]*[6])*(x-[7]))", 0, N_WF);

					func->SetParLimits(8, 0, 1.5 * NORM);//Singulet-state amplitude
						func->SetParName(8, "Amp_S");
						func->SetParameter(8, 1. * NORM);
					func->FixParameter(9, tauS);//Singulet-state time constant 
						func->SetParName(9, "Tau_S");
				
				case 1 :
					if(!func)
						func = new TF1("fit", "[0] + [1] *exp(-(1/[2]  + [3]*[4] + [5]*[6])*(x-[7]))", 0, N_WF);

					func->SetParLimits(0, 0, 1 * NORM);//Offset
						func->SetParName(0, "Offset");
						func->SetParameter(0, 0.);
					
					func->SetParLimits(1, 0, 1.5 * NORM);//Triplet-state amplitude
						func->SetParName(1, "Amp_T");
						func->SetParameter(1, 1. * NORM);
					func->FixParameter(2, tauT);//Triplet-state time constant 
						func->SetParName(2, "Tau_T");
					
					func->FixParameter(3, k_O2);  //k_O2
						func->SetParName(3, "k_O2");
					func->SetParLimits(4, 0, 1e2);//O2 concentration
						func->SetParName(4, "O2");
						func->SetParameter(4, 1.);
					func->FixParameter(5, k_N2);  //k_N2
						func->SetParName(5, "k_N2");
					func->SetParLimits(6, 0, 1e2);//N2 concentration
						func->SetParName(6, "N2");
						func->SetParameter(6, 1.);
					
					func->SetParLimits(7, peakTime-20, peakTime+20);//Peak time
						func->SetParName(7, "PeakTime");
					
					break;
				default :
					cout << "nExp value must be 1, 2 or 3" << endl;
					return NULL;
			}
			
			peakTimeNb = 7;
			
			break;
		case 3 : //Fitting O2 and N2 concentrations with saturation model
			switch(nExp)
			{
				case 3 :
					if(!func)
						func = new TF1("fit", "[0] + [1] *exp(-(1/[2]  + [3]*[8]*(1-exp(-[4]/[8])) + [5]*[9]*(1-exp(-[6]/[9])))*(x-[7])) \
															+ [10] *exp(-(1/[11]  + [3]*[8]*(1-exp(-[4]/[8])) + [5]*[9]*(1-exp(-[6]/[9])))*(x-[7])) \
															+ [12]*exp(-(1/[13]		+		[5]*[9]*(1-exp(-[6]/[9])))*(x-[7]))", 0, N_WF);
					
					func->SetParLimits(12, 0, 1.5 * NORM);//Intermediate state amplitude
						func->SetParName(12, "Amp_I");
						func->SetParameter(12, 1.5 * NORM);
					func->FixParameter(13, tauI);//Intermediate state time constant 
						func->SetParName(13, "Tau_I");
				
				case 2 :
					if(!func)
						func = new TF1("fit", "[0] + [1] *exp(-(1/[2]  + [3]*[8]*(1-exp(-[4]/[8])) + [5]*[9]*(1-exp(-[6]/[9])))*(x-[7])) \
															+ [10] *exp(-(1/[11]  + [3]*[8]*(1-exp(-[4]/[8])) + [5]*[9]*(1-exp(-[6]/[9])))*(x-[7]))", 0, N_WF);

					func->SetParLimits(10, 0, 1.5 * NORM);//Singulet-state amplitude
						func->SetParName(10, "Amp_S");
						func->SetParameter(10, 1.5 * NORM);
					func->FixParameter(11, tauS);//Singulet-state time constant 
						func->SetParName(11, "Tau_S");
				
				case 1 :
					if(!func)
						func = new TF1("fit", "[0] + [1] *exp(-(1/[2]  + [3]*[4]*(1-exp(-[4]/[8])) + [5]*[9]*(1-exp(-[6]/[9])))*(x-[7]))", 0, N_WF);

					func->SetParLimits(0, 0, 1 * NORM);//Offset
						func->SetParName(0, "Offset");
						func->SetParameter(0, 0.);
					
					func->SetParLimits(1, 0, 1.5 * NORM);//Triplet-state amplitude
						func->SetParName(1, "Amp_T");
						func->SetParameter(1, 1. * NORM);
					func->FixParameter(2, tauT);//Triplet-state time constant 
						func->SetParName(2, "Tau_T");
					
					func->FixParameter(3, k_O2);  //k_O2
						func->SetParName(3, "k_O2");
					func->SetParLimits(4, 0, 1e2);//O2 concentration
						func->SetParName(4, "O2");
						func->SetParameter(4, 1.);
					func->FixParameter(5, k_N2);  //k_N2
						func->SetParName(5, "k_N2");
					func->SetParLimits(6, 0, 1e2);//N2 concentration
						func->SetParName(6, "N2");
						func->SetParameter(6, 1.);
					
					func->SetParLimits(7, peakTime-20, peakTime+20);//Peak time
						func->SetParName(7, "PeakTime");

					func->FixParameter(8, beta_O2);  //beta_02
						func->SetParName(8, "Beta_O2");
					func->FixParameter(9, beta_N2);  //beta_N2
						func->SetParName(9, "Beta_N2");
					
					break;
				default :
					cout << "nExp value must be 1, 2 or 3" << endl;
					return NULL;
			}
			
			peakTimeNb = 7;
			
			break;
		case 4 : //Fitting only for the triplet state on log plot
		
				func = new TF1("fit", "[0] - x/[1]", 0, N_WF);

				func->SetParLimits(0, 0, 25);
				func->SetParName(0, "Offset");
				func->SetParameter(0, 0.);
				
				func->SetParLimits(1, 0, 1e4);//Triplet-state time constant
				func->SetParName(1, "Tau_T");
				func->SetParameter(1, 1000.);

			break;
	}
	
	if(fixPeakTime && option != 4)
		func->FixParameter(peakTimeNb, peakTime);
	
	return func;
}










